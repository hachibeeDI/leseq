"use strict";(self.webpackChunkleseq_docs=self.webpackChunkleseq_docs||[]).push([[81],{876:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),y=u(n),m=a,d=y["".concat(s,".").concat(m)]||y[m]||c[m]||o;return n?r.createElement(d,i(i({ref:t},p),{},{components:n})):r.createElement(d,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=y;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}y.displayName="MDXCreateElement"},8795:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return p},metadata:function(){return y},toc:function(){return m}});var r=n(7896),a=n(1461),o=(n(2784),n(876)),i=["components"],l={toc:[{value:"Equality Strategy",id:"equality-strategy",children:[],level:2},{value:"Predefined Generators",id:"predefined-generators",children:[],level:2},{value:"Predefined Operators",id:"predefined-operators",children:[],level:2},{value:"Predefined Values",id:"predefined-values",children:[],level:2},{value:"Original Operator",id:"original-operator",children:[],level:2},{value:"Original Value",id:"original-value",children:[],level:2}]};function s(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://badge.fury.io/js/leseq"},(0,o.kt)("img",{parentName:"a",src:"https://badge.fury.io/js/leseq.svg",alt:"npm version"}))),(0,o.kt)("p",null,"Lazy evaluation list with high tree-shaking affinity and easy customization."),(0,o.kt)("h1",{id:"features"},"Features"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\ud83c\udf81 ",(0,o.kt)("strong",{parentName:"li"},"Lazy Evaluation"),": The collection is enumerated only as far as it needs to be, and never more than once."),(0,o.kt)("li",{parentName:"ul"},"\ud83c\udf84 ",(0,o.kt)("strong",{parentName:"li"},"Tree-Shakeable"),": Only the features you use will be bundled."),(0,o.kt)("li",{parentName:"ul"},"\ud83d\udcce ",(0,o.kt)("strong",{parentName:"li"},"Easy-customization"),": You can easily create the functions you need by yourself."),(0,o.kt)("li",{parentName:"ul"},"\ud83d\uddc2 ",(0,o.kt)("strong",{parentName:"li"},"Rxjs-like syntax"),": To achieve tree-shaking, we use an ",(0,o.kt)("a",{parentName:"li",href:"https://rxjs.dev/"},"rxjs"),"-like syntax."),(0,o.kt)("li",{parentName:"ul"},"\ud83d\udcaf ",(0,o.kt)("strong",{parentName:"li"},"All Typed"),": The whole thing is written in TypeScript, which also provides completion for type conversion between operators."),(0,o.kt)("li",{parentName:"ul"},"\ud83d\udca8 ",(0,o.kt)("strong",{parentName:"li"},"No dependencies"))),(0,o.kt)("h1",{id:"getting-started"},"Getting Started"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install leseq\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {from, map, take, find} from 'leseq';\n\nconst result1 = from([1,2,3,4,5]).pipe(\n  map(i => i * i),\n  take(3)\n).toArray();\n\n//result1: [1,4,9]\n\nconst result2 = from([1,2,3,4,5]).pipe(\n  filter(i => i % 2 == 0)\n).value(\n  find(i => i > 2)\n);\n\n//result2: 4\n")),(0,o.kt)("p",null,"Here are the results of the Bundle Analyzer for the above example. You can see that only functions you are using are bundled.(seq.js is core object.)"),(0,o.kt)("img",{width:"500",src:"https://user-images.githubusercontent.com/1430166/154478759-126c874e-e33c-4f6e-a5f7-e4ba9c8e0211.png"}),(0,o.kt)("h1",{id:"live-demo"},"Live Demo"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://stackblitz.com/edit/typescript-vygaa6?file=index.ts"},"Demo(StackBlitz)"))),(0,o.kt)("h1",{id:"usage"},"Usage"),(0,o.kt)("p",null,"You can generate a sequence(Seq","<","T",">"," object) with ",(0,o.kt)("strong",{parentName:"p"},"Generator"),", perform transformations and other operations with any number of ",(0,o.kt)("strong",{parentName:"p"},"Operators"),", and convert it to a value with ",(0,o.kt)("strong",{parentName:"p"},"Value"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"Generators(ex: from, fromConcat, ..etc).pipe(\n  ...Operators(ex: map, filter, ...etc)\n).value(Values(ex: toArray,find,some, ...etc))\n")),(0,o.kt)("h2",{id:"equality-strategy"},"Equality Strategy"),(0,o.kt)("p",null,"Some Operators, such as uniq, groupBy, union, etc., can take ",(0,o.kt)("strong",{parentName:"p"},"keySelector")," and ",(0,o.kt)("strong",{parentName:"p"},"comparableValueForKey")," as arguments. If the key is a string or a number, there is nothing to worry about, but if the key is an object, you need to be careful."),(0,o.kt)("p",null,"If the key is an object, it will be processed using the so-called ",(0,o.kt)("em",{parentName:"p"},'"reference equality"')," of the object unless ",(0,o.kt)("strong",{parentName:"p"},"comparableValueForKey")," argument is specified at the same time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const source = [\n  {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test1\"},\n  {groupKey: {mainKey: 2, subKey: 'b'}, value: \"test2\"},\n  {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test3\"},\n  {groupKey: {mainKey: 1, subKey: 'c'}, value: \"test4\"},\n]\n\nconst output1 = from(source).pipe(groupBy(one => one.groupKey)).toArray();\n\n/*\nunwanted result \xd7\nresult: [\n  {key: {mainKey: 1, subKey: 'a'}, values: [\n    {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test1\"}\n  ]},\n  {key: {mainKey: 2, subKey: 'b'}, values: [\n    {groupKey: {mainKey: 2, subKey: 'b'}, value: \"test2\"}\n  ]},\n  {key: {mainKey: 1, subKey: 'a'}, values: [\n    {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test3\"}\n  ]},\n  {key: {mainKey: 1, subKey: 'c'}, values: [\n    {groupKey: {mainKey: 1, subKey: 'c'}, value: \"test4\"}\n  ]}\n]\n*/\n")),(0,o.kt)("p",null,"If key is an object and you want to process it using the so-called ",(0,o.kt)("em",{parentName:"p"},'"value equality"')," of key, specify ",(0,o.kt)("strong",{parentName:"p"},"comparableValueForKey")," and make sure that ",(0,o.kt)("strong",{parentName:"p"},"comparableValueForKey")," returns the same value for all objects that can be considered structurally unique to the extent necessary.  (In many cases, using hash function is excessive.)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const comparableValueForKey = (key: {mainKey: number, subKey: string}) => key.mainKey + key.subKey;\n\nconst output2 = from(source).pipe(uniq(one => one.groupKey,i => i, comparableValueForKey)).toArray();\n\n/*\nas expected \u3007\nresult: [\n  {key: {mainKey: 1, subKey: 'a'}, values: [\n    {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test1\"},\n    {groupKey: {mainKey: 1, subKey: 'a'}, value: \"test3\"}\n  ]},\n  {key: {mainKey: 2, subKey: 'b'}, values: [\n    {groupKey: {mainKey: 2, subKey: 'b'}, value: \"test2\"}\n  ]},\n  {key: {mainKey: 1, subKey: 'c'}, values: [\n    {groupKey: {mainKey: 1, subKey: 'c'}, value: \"test4\"}\n  ]},\n]\n*/\n")),(0,o.kt)("p",null,"The predefined ",(0,o.kt)("strong",{parentName:"p"},"Generators/Operators/Values")," are as follows.\nIf the function you want to use does not exist, you can also define your own Operator/Value function ",(0,o.kt)("a",{parentName:"p",href:"#create-original-functions"},"in this way"),"."),(0,o.kt)("h2",{id:"predefined-generators"},"Predefined Generators"),(0,o.kt)("h2",{id:"predefined-operators"},"Predefined Operators"),(0,o.kt)("p",null,"It is used within the pipe method of the Seq","<","T",">"," object. Any number of operators can be connected."),(0,o.kt)("h2",{id:"predefined-values"},"Predefined Values"),(0,o.kt)("p",null,"Generates a value from a sequence. Used in the value method of the Seq","<","T",">"," object."),(0,o.kt)("h1",{id:"create-original-functions"},"Create original functions"),(0,o.kt)("h2",{id:"original-operator"},"Original Operator"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Seq, from, type Gen } from 'leseq';\n\nconst mapOriginal = <T, TResult>(func: (arg: T, index: number) => TResult) =>\n  function* (source: Seq<T>): Gen<TResult> {\n    let count = 0;\n    for (const i of source) {\n      const result = func(i, count);\n      yield result;\n      count++;\n    }\n  };\n\nconst result = from([1,2,3]).pipe(\n  mapOriginal(i => i * i)\n).toArray();\n\n//result: [1,4,9]\n")),(0,o.kt)("h2",{id:"original-value"},"Original Value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Seq, from } from 'leseq';\n\nconst everyOriginal =\n  <T>(predicate: (arg: T) => boolean) =>\n  (seq: Seq<T>): boolean => {\n    for (const i of seq) {\n      if (!predicate(i)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\nconst result = from([2,4,6]).value(everyOriginal(i => i % 2 == 0));\n\n//result: true\n")))}s.isMDXComponent=!0;var u=["components"],p={id:"overview",title:"leseq",sidebar_label:"overview",sidebar_position:.5,custom_edit_url:null,hide_title:!0,slug:"/"},c=void 0,y={unversionedId:"overview",id:"overview",title:"leseq",description:"",source:"@site/docs/overview.mdx",sourceDirName:".",slug:"/",permalink:"/leseq/",editUrl:null,tags:[],version:"current",sidebarPosition:.5,frontMatter:{id:"overview",title:"leseq",sidebar_label:"overview",sidebar_position:.5,custom_edit_url:null,hide_title:!0,slug:"/"},sidebar:"mainSidebar",next:{title:"generators",permalink:"/leseq/api/generators/"}},m=[],d={toc:m};function f(e){var t=e.components,n=(0,a.Z)(e,u);return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(s,{mdxType:"README"}))}f.isMDXComponent=!0}}]);